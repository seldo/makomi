{
  "name": "socket.io-sessions",
  "description": "Use your sessions from Connect, Express and others with Socket.IO",
  "url": "http://github.com/aviddiviner/Socket.IO-sessions",
  "keywords": [
    "connect",
    "express",
    "socket.io",
    "session",
    "sessions"
  ],
  "author": {
    "name": "David Irvine",
    "email": "aviddiviner@gmail.com"
  },
  "contributors": [],
  "licenses": [
    "MIT"
  ],
  "dependencies": {},
  "main": "./index",
  "version": "0.6.1",
  "repository": {
    "type": "git",
    "url": "git://github.com/aviddiviner/Socket.IO-sessions.git"
  },
  "engines": {
    "node": ">= 0.4.1"
  },
  "readme": "Socket.IO-sessions\n==================\n\nA simple library for [Node.js](https://github.com/joyent/node) that allows you to easily use your sessions from [Connect](http://github.com/senchalabs/Connect), [Express](http://github.com/visionmedia/express) and others with [Socket.IO](http://github.com/LearnBoost/Socket.IO-node).\n\n\n## Installation\n    npm install socket.io-sessions\n\n\n## How To Use\nThis library provides two methods of linking your session data with Socket.IO's connections. You can either reload the session from the store per-connection or per-message.\n\n### TL;DR Version\nThe basic idea is that on new Socket.IO connection, you auto-magically have a callback like `function(client, session)` instead of just `function(client)`, giving you access to your session store data.\n\n#### Server\n    var connect = require('connect'),\n        io      = require('socket.io'),\n        sio     = require('socket.io-sessions');\n\n    var mystore = new MemoryStore;        // or RedisStore, etc\n    var app = connect.createServer(...);  // With sessions\n\n    var socket = sio.enable({\n      socket: io.listen(app),         // Socket.IO listener\n      store:  mystore,                // Your session store\n      parser: connect.cookieParser()  // Cookie parser\n    });\n\nThis adds a new event which you can listen for using `socket.on(...)`, namely `sconnection`. It looks something like this:\n\n    socket.on('sconnection', function(client, session){\n        // Play with the session, saved on disconnect\n    });\n\n#### Client\nOn the client side, you simply need to include a link to the JS file and then connect using `io.connectWithSession()` instead of `io.connect()`.\n\n    <script src=\"/socket.io/socket.io.js\"></script>\n    <script src=\"/socket.io/socket.io-sessions.js\"></script>\n    <script>\n      var socket = io.connectWithSession();\n      ...\n    </script>\n\nThat's it! You're done. Everything else is as normal. Feel free to read on if you'd like a more detailed explanation though.\n\n\n\n## Server Configuration\nLet's have a better look at some example usage. Assuming we have the following basic app, using Connect:\n\n    var connect = require('connect'),\n        io      = require('socket.io'),\n        sio     = require('socket.io-sessions');\n\n    // Create the session store\n    var MemoryStore = require('connect/lib/middleware/session/memory');\n    mystore = new MemoryStore;\n\n    // Create the webserver\n    var app = connect.createServer(\n        connect.cookieParser(),\n        connect.session({secret:'faceroll here', store:mystore}),\n        function(req, res, next){\n            res.end('Hello World!');\n            // var session = req.session;\n        }\n    );\n\n    // Listen with Socket.IO\n    var iolistener = io.listen(app);\n\n    app.listen(3000); // Start the webserver\n\nTo allow Socket.IO to access our sessions, we insert the following:\n\n    // Make Socket.IO session aware\n    var socket = sio.enable({\n      socket: iolistener,\n      store:  mystore,\n      parser: connect.cookieParser()\n    });\n\nThis adds new events that we can listen for using the `socket.on(...)` listener. Let's take a look at how we use these.\n\n### Per-connection session handling\nThis method loads the session from the store at the start of the connection, and then writes it on disconnect. You do this by adding a listener for the `sconnection` event, as follows:\n\n    socket.on('sconnection', function(client, session){\n        // Client connected, session loaded\n        client.on('message', function(message){ ... });\n        client.on('disconnect', function(){\n            // Client disconnected, session saved after this callback\n        });\n    });\n\nIt is worth noting that if your application crashes, then the post-disconnect callback will never be called. So any changes you made to the session while that connection was active would be lost.\n\n### Per-message session handling\nThis method will reload the session each time a message is received and then write it back to the store after firing the `smessage` callback. You use this by passing the `per_message:true` option, as follows:\n\n    var socket = sio.enable({\n      socket: io.listen(app),\n      store:  mystore,\n      parser: connect.cookieParser(),\n      per_message: true   // <-- Add this option\n    });\n\n    socket.on('sconnection', function(client){\n        client.on('smessage', function(message, session){\n            // Play with the session, it gets saved after this callback\n        });\n        client.on('disconnect', function(){ ... });\n    });\n\n### Using a different session store (e.g. Redis)\nThis is as simple as swopping out the two lines in our server code above with:\n\n    // Create the session store\n    var RedisStore = require('connect-redis');\n    mystore = new RedisStore;\n\n### Using Express or some other framework\nIf you were using Express, then your app declaration would look something like the following:\n\n    // Create the webserver\n    var app = express.createServer();\n    app.use(express.cookieParser());\n    app.use(express.session({ store: mystore });\n    app.get('/', function(req, res){\n        res.send('Hello World!');\n    });\n    app.listen(3000);\n\n### Expired session handling\n\nThere is an extra event called `sinvalid` which is fired if the session isn't found in the session store or if there is an error retrieving it. This is handled as follows.\n\n    socket.on('sinvalid', function(client){\n        // Session invalid or not found in the store.\n        // Send the client some instructions to refresh.\n    });\n\n### Cutting cookies\nIn each example above, we've included a `cookieParser()` callback. This callback is used so that when the browser requests the client Javascript file, it takes the session ID from its cookie and bundles this along with the client code.\n\nIf you aren't using Connect or Express however, then you may be handling sessions differently. In this case you need to pass a callback that will allow the server to get the session ID from the given HTTP Request object, as follows:\n\n    var socket = sio.enable({\n      socket: io.listen(app),\n      store:  session_store,\n      cutter: myCookieCutter  // Note: cutter, not parser\n    });\n\nHere are two examples of such callbacks:\n\n    var connectCookieCutter = function(req){\n      var cookie = connect.utils.parseCookie(req.headers['cookie']);\n      return cookie['connect.sid'];\n    };\n\n    var expressCookieCutter = function(req){\n      var parser = express.cookieParser();\n      parser(req, null, function(){});\n      return req.cookies['connect.sid'];\n    };\n\nThe session ID returned from this callback will be the ID used to retrieve the session data from the store using a call to `store.get(sid, ...)`.\n\n\n\n## Client Configuration\nThe client configuration is really straightforward. All that is required is that the client JS link is included and then your client code is as usual, except using `var socket = io.SessionSocket()`.\n\nThe default path to the client JS is `/socket.io/socket.io-sessions.js`. Note that if you change the default path of Socket.IO from `/socket.io`, using the `socket.options.resource` setting, then this will also change the base path of this client JS.\n\n### Browser caching\nIt is possible that the browser might cache the Javascript file, which can cause problems if the session expires or the session ID becomes invalid, since this is served inline with the JS. In this case, just add a timestamp to the link. If you're using express, this is how you do it:\n\n    // In your view (EJS):\n    <script src=\"/socket.io/socket.io-sessions.js?<%= timestamp %>\"></script>\n\n    // In your app:\n    app.get('/', function(req,res){\n        res.render('index.ejs', {\n            locals: { \n                timestamp: (new Date()).getTime()\n            }\n        }\n    });\n\n### Example page\nLet's take a look at an example HTML page:\n\n    <script src=\"/socket.io/socket.io.js\"></script>\n    <script src=\"/socket.io/socket.io-sessions.js\"></script>\n    <script>\n      var logmsg = function(msg){\n        document.getElementById('msgbox').innerHTML += msg + '\\n'; \n      };\n      var socket = io.connectWithSession();\n      socket.on('connect', function(){\n        logmsg('<b>Connect!</b>');\n      });\n      socket.on('message', function(message){\n        logmsg('Message: ' + JSON.stringify(message));\n      });\n    </script>\n    <input id=\"sendmsg\" type=\"button\" value=\"Ping!\"\n      onclick=\"socket.send('ping', function(){ logmsg('(msg sent)'); });\" />\n    <pre id=\"msgbox\"></pre>\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/aviddiviner/Socket.IO-sessions/issues"
  },
  "_id": "socket.io-sessions@0.6.1",
  "dist": {
    "shasum": "ebb5d47df617377ae6e9f77f880e2ffda7d7984a"
  },
  "_from": "socket.io-sessions@*",
  "_resolved": "https://registry.npmjs.org/socket.io-sessions/-/socket.io-sessions-0.6.1.tgz"
}
